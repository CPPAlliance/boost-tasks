#!/usr/bin/env php
<?php

require_once(__DIR__.'/vendor/autoload.php');

function main() {
    $options = CommandLineOptions::process($_SERVER['argv'],
        'Update the website development documentation from BinTray.');
    EvilGlobals::init($options);

    foreach(array('master', 'develop') as $branch) {
        try {
            update_documentation($branch);
        }
        catch(RuntimeException $e) {
            Log::error($e);
        }
    }
}

function update_documentation($branch) {
    // TODO: Resolve path
    $archives_path = EvilGlobals::settings('website-archives');
    if (!$archives_path) {
        throw new RuntimeException("website-archives not set");
    }
    if (!is_dir($archives_path)) {
        throw new RuntimeException("website-archives not a directory");
    }
    $archives_path = rtrim($archives_path, '/');

    // Download file from bintray...
    $cache = new BinTrayCache;
    $file_list = $cache->fetch_details($branch);

    // TODO: Store date instead of version?
    $destination_path = "{$archives_path}/{$branch}";
    $version = is_file("{$destination_path}/.bintray-version") ?
        file_get_contents("{$destination_path}/.bintray-version") :
        '';

    foreach($file_list as $file) {
        if ($version == $file->version) { return; }

        // Download tarball.
        $file_path = $cache->cached_download($file);
        if (!$file_path) { continue; }

        $cache->cleanup($branch);

        Log::info("Extracting {$file_path} to {$destination_path}.");

        // Extract into a temporary directory.
        $temp_directory = new TemporaryDirectory("{$archives_path}/tmp");
        switch($file->extension) {
        case 'tar.bz2':
            Process::run("tar -xjf '{$file_path}'", $temp_directory->path, null, null, 60*10);
            break;
        case 'tar.gz':
            Process::run("tar -xzf '{$file_path}'", $temp_directory->path, null, null, 60*10);
            break;
        case '7z':
            Process::run("7z x '{$file_path}'", $temp_directory->path, null, null, 60*10);
            break;
        case 'zip':
            Process::run("unzip '{$file_path}'", $temp_directory->path, null, null, 60*10);
            break;
        default:
            assert(false);
        }

        // Find the extracted tarball in the temporary directory.
        $new_directories = array_filter(scandir($temp_directory->path), function($x) { return $x[0] != '.'; });
        if (count($new_directories) != 1) {
            throw new RuntimeException("Something went wrong extracting archive");
        }
        $extract_path = "{$temp_directory->path}/".reset($new_directories);

        // Add the version details.
        file_put_contents("{$extract_path}/.bintray-version", $file->version);

        // Replace the old documentation.
        // Would be nice to overwrite old archive in a cleaner manner...
        if (realpath($destination_path)) { rename($destination_path, "{$temp_directory->path}/old"); }
        rename($extract_path, $destination_path);

        return;
    }

    throw new RuntimeException("Unable to download any of the files.");
}

class TemporaryDirectory {
    var $path;

    function __construct($tmp_root = null) {
        if (is_null($tmp_root)) { $tmp_root = sys_get_temp_dir(); }

        if (!is_dir($tmp_root)) {
            throw new RuntimeException("Temporary directory doesn't exist: {$tmp_root}");
        }

        if (!is_writable($tmp_root)) {
            throw new RuntimeException("Temporary directory isn't writable: {$tmp_root}");
        }

        // Create temporary directory.
        // Race condition here, but seems unlikely to be a real problem.
        $temp_name = tempnam($tmp_root, "download");
        if (!$temp_name) { return false; }
        if (strpos($temp_name, "{$tmp_root}/") !== 0) {
            throw new RuntimeException("Incorrect location for temporary directory.");
        }
        unlink($temp_name);
        mkdir($temp_name);
        $temp_name = realpath($temp_name);
        if (!$temp_name || !is_dir($temp_name) || strpos($temp_name, "{$tmp_root}/") !== 0) {
            throw new RuntimeException("Something went wrong creating temporary directory.");
        }

        $this->path = $temp_name;
    }

    function __destruct() {
        if ($this->path) { recursive_remove($this->path); }
    }

    function getPath() {
        return $this->path;
    }
}

// TODO: Better error handling.
function recursive_remove($path) {
    if (is_file($path) || is_link($path)) {
        unlink($path);
    }
    else if (is_dir($path)) {
        foreach(scandir($path) as $child) {
            if ($child == '.' || $child == '..') { continue; }
            $child_path = "{$path}/{$child}";
            recursive_remove($child_path);
        }
        rmdir($path);
    }
}

class BinTrayCache {
    var $path;

    function __construct() {
        $this->path = EvilGlobals::data_path('bintray');
    }

    function fetch_details($branch) {
        // Not using 7zip files because 7z doesn't seem to be installed on the server.
        $extension_priorities = array_flip(array('tar.bz2', 'tar.gz', 'zip'));
        $low_priority = 100;

        // Download the file list from bintray.
        $files = file_get_contents(
            "https://api.bintray.com/packages/boostorg/{$branch}/snapshot/files");
        if (!$files) {
            throw new RuntimeException("Error downloading file details from bintray.");
        }

        $files = json_decode($files);
        if (!$files) {
            throw new RuntimeException("Error parsing latest details.");
        }

        $file_list = array();
        foreach($files as $x) {
            list($x_base_name, $x_extension) = explode('.', $x->name, 2);
            if (array_key_exists($x_extension, $extension_priorities)) {
                $x->priority = $extension_priorities[$x_extension];
                $x->extension = $x_extension;
                $file_list[] = $x;
            }
        }
        if (!$file_list) {
            throw new RuntimeException("Unable to find file to download.");
        }

        // If two files have different versions, use most recent.
        // Otherwise sort by priority.
        usort($file_list, function($x, $y) {
            return
                -($x->version != $y->version
                    ? strtotime($x->created) - strtotime($y->created) : 0) ?:
                ($x->priority - $y->priority);
        });

        return $file_list;
    }

    // Return path the file was downloaded to, null if the file isn't available.
    // Throws an exception if something goes wrong while downloading, or the
    // hash of the downloaded file doesn't match.
    function cached_download($file) {
        $date = date('Y-m-d\TH:i', strtotime($file->created));
        // 'repo' is actually the branch, that's just the way bintray is organised.
        $download_dir = "{$this->path}/{$file->repo}/{$date}/{$file->sha1}";
        $download_path = "{$download_dir}/{$file->name}";

        if (!is_file($download_path)) {
            if (!is_dir($download_dir)) {
                mkdir($download_dir, 0777, true);
            }

            if (!$this->download_file(
                "http://dl.bintray.com/boostorg/{$file->repo}/{$file->name}",
                $download_path))
            {
                return null;
            }
        }

        if (hash_file('sha256', $download_path) != $file->sha256) {
            Log::error("File signature doesn't match: {$download_path}");
            throw new RuntimeException("File signature doesn't match");
        }

        return $download_path;
    }

    // TODO: Download to temporary file and move into position.
    // TODO: Better error handling, what to do if there's a failure during download?
    function download_file($url, $dst_path) {
        Log::info("Downloading {$url} to {$dst_path}.");
        $download_fh = fopen($url, 'rb');
        if (!$download_fh) { return false; }

        $save_fh = fopen($dst_path, "wb");
        if (!$save_fh) {
            throw new RuntimeException("Problem opening local file to write to.");
        }

        while (!feof($download_fh)) {
            $chunk = fread($download_fh, 8192);
            if ($chunk === false) {
                throw new RuntimeException("Problem reading chunk.");
            }
            if (fwrite($save_fh, $chunk) === false) {
                throw new RuntimeException("Problem writing chunk.");
            }
        }

        return true;
    }

    function cleanup($branch = null) {
        $dirs = array();
        if (is_null($branch)) {
            foreach(scandir($this->path) as $dir) {
                if ($dir[0] === '.') { continue; }
                $dirs[] = realpath("{$this->path}/{$dir}");
            }
        }
        else {
            // Error if branch doesn't exist?
            $path = realpath("{$this->path}/{$branch}");
            if ($path) { $dirs[] = $path; }
        }

        foreach($dirs as $dir) {
            $children = array();
            foreach(scandir($dir) as $child) {
                if ($child[0] === '.') { continue; }
                // Q: Accept any time? Or just the ones that are generated.
                $timestamp = strtotime($child);
                if ($timestamp === FALSE) {
                    Log::warning("Invalid cache dir: {$dir}/{$child}");
                }
                else {
                    $children[$child] = $timestamp;
                }
            }

            $delete_before = max($children) - 5*60*60;
            foreach($children as $child_dir => $timestamp) {
                if ($timestamp < $delete_before) {
                    recursive_remove("{$dir}/{$child_dir}");
                }
            }
        }
    }
}

main();
